"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WidgetBuilder = void 0;
const path = __importStar(require("path"));
const fse = __importStar(require("fs-extra"));
const _ = __importStar(require("lodash"));
const async = __importStar(require("async"));
const consola_1 = __importDefault(require("consola"));
const axios_1 = __importDefault(require("axios"));
const globby_1 = __importDefault(require("globby"));
const jszip_1 = __importDefault(require("jszip"));
const uniqid_1 = __importDefault(require("uniqid"));
const default_manifest_1 = require("./default-manifest");
const images_1 = require("./images");
class WidgetBuilder {
    constructor(config = {}) {
        var _a;
        this.config = config;
        this.manifest = {};
        this.debugKey = `rsDebugUrl_${(_a = this.config.debugKey) !== null && _a !== void 0 ? _a : uniqid_1.default()}`;
    }
    async init() {
        try {
            await this.clean();
            await this.createTempFolder();
            await this.mergeManifest();
            await this.prepareImages();
            await this.prepareLocalesFiles();
            await this.prepareManifest();
            await this.prepareScript();
            await this.prepareBundle();
            await this.zip();
            if (this.cleanOnFinish)
                await this.clean();
        }
        catch (e) {
            consola_1.default.error(e);
        }
    }
    get bundleDir() {
        if (!this.config.bundleDir) {
            throw new Error('Не указана директория с бандлом');
        }
        return this.config.bundleDir;
    }
    get entryPoint() {
        return this.config.entryPoint || 'bundle.js';
    }
    get entryPointIsURL() {
        return !!this.entryPoint.match(/^https?:\/\//);
    }
    get cleanOnFinish() {
        const { cleanOnFinish } = this.config;
        return cleanOnFinish === undefined ? true : cleanOnFinish;
    }
    get sourceImagesDir() {
        return this.config.imagesDir || null;
    }
    get localesKeys() {
        return Array.isArray(this.locales) ? [...this.locales] : Object.keys(this.locales);
    }
    get locales() {
        return _.get(this.config, ['locales'], ['ru']);
    }
    get fakeImageConnector() {
        return axios_1.default.create({
            baseURL: 'https://fakeimg.pl',
            responseType: 'stream'
        });
    }
    get fakeImageColors() {
        var _a, _b, _c, _d, _e, _f;
        return {
            text: ((_c = (_b = (_a = this.config.fakeImages) === null || _a === void 0 ? void 0 : _a.colors) === null || _b === void 0 ? void 0 : _b.text) !== null && _c !== void 0 ? _c : 'fff').replace('#', ''),
            background: ((_f = (_e = (_d = this.config.fakeImages) === null || _d === void 0 ? void 0 : _d.colors) === null || _e === void 0 ? void 0 : _e.background) !== null && _f !== void 0 ? _f : '088bc4').replace('#', '')
        };
    }
    async clean() {
        await fse.remove(this.tempWidgetPath);
        consola_1.default.success('Временная папка удалена');
    }
    async zip() {
        const zip = new jszip_1.default();
        const filePaths = await globby_1.default(['**', '!*.zip'], { cwd: this.tempWidgetPath });
        filePaths.forEach(filePath => {
            zip.file(filePath, fse.readFile(path.resolve(this.tempWidgetPath, filePath)));
        });
        const archive = (await zip.generateAsync({ type: 'nodebuffer' }));
        await fse.writeFile(this.archivePath, archive);
        const stats = await fse.stat(this.archivePath);
        consola_1.default.info('Путь до архива', this.archivePath);
        consola_1.default.info('Размер архива', `${Math.round(stats.size / 1024)} KB`);
        consola_1.default.success('Архив готов');
        return this.archivePath;
    }
    mergeManifest() {
        var _a;
        Object.keys(((_a = this.config.manifest) === null || _a === void 0 ? void 0 : _a.settings) || {}).forEach(settingKey => {
            if (_.get(default_manifest_1.defaultManifest, ['settings', settingKey])) {
                delete default_manifest_1.defaultManifest.settings[settingKey];
            }
        });
        if (!this.config.disableAdvancedSettings) {
            _.set(this.config, 'disableAdvancedSettings', false);
        }
        if (this.config.fakeConfig) {
            _.merge(default_manifest_1.defaultManifest.settings.fakeConfig, this.config.fakeConfig);
        }
        this.manifest = _.mergeWith(default_manifest_1.defaultManifest, this.config.manifest, (value, srcValue) => {
            if (Array.isArray(srcValue))
                return srcValue;
        });
        if (Array.isArray(this.config.locations)) {
            this.manifest.locations = this.config.locations;
        }
        if (this.config.advancedSettingsTitle) {
            const { locations } = this.manifest;
            if (!locations.includes('advanced_settings')) {
                locations.push('advanced_settings');
            }
            if (!this.manifest.advanced) {
                this.manifest.advanced = {
                    title: 'advanced.title'
                };
            }
        }
        _.set(this.manifest, ['widget', 'locale'], [...this.localesKeys]);
    }
    async prepareManifest() {
        await fse.writeJson(path.resolve(this.tempWidgetPath, 'manifest.json'), this.manifest);
        consola_1.default.success('Манифест готов');
    }
    async prepareImages() {
        await this.createImagesFolder();
        const imagesKeys = Object.keys(images_1.images);
        await async.eachSeries(imagesKeys, async (imageKey) => {
            const ext = imageKey === 'home_page' ? 'svg' : 'png';
            const imagePath = this.sourceImagesDir && path.resolve(this.sourceImagesDir, `${imageKey}.${ext}`);
            const buffer = await this.getOrGenerateImage(imagePath, { size: images_1.images[imageKey].size, text: imageKey });
            return fse.writeFile(path.resolve(this.imagesPath, `${imageKey}.${ext}`), buffer);
        });
        await async.eachSeries(this.localesKeys, async (localeKey) => {
            let tourImagesPaths = [];
            if (this.sourceImagesDir) {
                tourImagesPaths = await globby_1.default([`tour/${localeKey}/**.png`, `tour/${localeKey}/**.jpg`, `tour/${localeKey}/**.gif`], {
                    cwd: path.resolve(this.sourceImagesDir)
                });
            }
            if (!tourImagesPaths.length) {
                tourImagesPaths = _.times(3, i => `tour/${localeKey}/tour_${i + 1}.png`);
            }
            _.set(this.manifest, ['tour', 'tour_images', localeKey], tourImagesPaths.map(path => `/images/${path}`));
            await fse.mkdir(path.resolve(this.tourImagesPath, localeKey), { recursive: true });
            await async.eachOfSeries(tourImagesPaths, async (tourImagePath, index) => {
                const imagePath = this.sourceImagesDir && path.resolve(this.sourceImagesDir, tourImagePath);
                const buffer = await this.getOrGenerateImage(imagePath, {
                    size: [1188, 616],
                    text: `tour_${index + 1}`
                });
                return fse.writeFile(path.resolve(this.imagesPath, tourImagePath), buffer);
            });
        });
        consola_1.default.success('Изображения готовы');
    }
    async getOrGenerateImage(imagePath, fakeConfig) {
        const exists = imagePath && (await fse.pathExists(imagePath));
        if (exists) {
            return fse.readFile(imagePath);
        }
        else {
            return this.getFakeImage(fakeConfig);
        }
    }
    async getFakeImage(fakeConfig) {
        const { size: [width, height], text } = fakeConfig;
        const params = {};
        if (text)
            params.text = text;
        const colors = this.fakeImageColors;
        const response = await this.fakeImageConnector.get(`/${width}x${height}/${colors.background}/${colors.text}/`, {
            params
        });
        const chunks = [];
        await new Promise(resolve => {
            response.data.on('data', (chunk) => chunks.push(chunk));
            response.data.on('end', resolve);
        });
        return Buffer.concat(chunks);
    }
    async prepareLocalesFiles() {
        await this.createLocalesFolder();
        await async.each(this.localesKeys, async (localeKey) => {
            const locale = Array.isArray(this.locales) ? true : this.locales[localeKey];
            const data = typeof locale === 'boolean' && locale ? {} : locale;
            [
                ['name', 'widget.name'],
                ['description', 'widget.description'],
                ['shortDescription', 'widget.short_description'],
                ['tourDescription', 'tour.tour_description'],
                ['advancedSettingsTitle', 'advanced.title']
            ].forEach(([configProp, manifestProp]) => {
                if (manifestProp === 'advanced.title' && _.get(this.config, 'disableAdvancedSettings'))
                    return;
                const configValue = _.get(this.config, configProp);
                let localePath = _.get(this.manifest, manifestProp);
                if (!localePath) {
                    localePath = manifestProp;
                    _.set(this.manifest, manifestProp, localePath);
                }
                let value;
                if (typeof configValue === 'string') {
                    value = configValue;
                }
                else if (typeof configValue === 'object') {
                    value = _.get(configValue, localeKey);
                }
                _.set(data, localePath, value || `Empty ${configProp}`);
            });
            const { settings = {} } = this.manifest;
            Object.keys(settings).forEach(settingKey => {
                const setting = settings[settingKey];
                let name = _.get(setting, 'name');
                if (!name) {
                    name = `settings.${settingKey}`;
                    _.set(setting, 'name', name);
                }
                const locale = _.get(data, name);
                if (!locale)
                    _.set(data, name, settingKey);
            });
            return await fse.writeJson(path.resolve(this.localesPath, `${localeKey}.json`), data);
        });
        consola_1.default.success('Файлы локализации готовы');
    }
    async prepareScript() {
        const scriptFile = await fse.readFile(path.resolve(__dirname, '../static/script.js'), 'utf8');
        const entrypoint = this.entryPointIsURL
            ? this.entryPoint
            : await (async () => {
                let filePath = this.entryPoint;
                const exist = await fse.pathExists(path.resolve(this.bundleDir, this.entryPoint));
                if (!exist) {
                    consola_1.default.info(`Входная точка не найдена, попытка найти файл с хешем`);
                    const split = this.entryPoint.split('.');
                    split.splice(split.length - 1, 0, '.+?');
                    const filePaths = await globby_1.default(['*.js', '**/*.js'], { cwd: this.bundleDir });
                    const regEx = new RegExp(`^${split.join('\\.')}$`);
                    const found = filePaths.find(path => path.match(regEx));
                    if (found) {
                        consola_1.default.info(`Входная точка с хешем найдена`);
                        filePath = found;
                    }
                    else {
                        throw new Error('Входная точка не найдена');
                    }
                }
                return `./build/${filePath}`;
            })();
        consola_1.default.info('Входная точка', entrypoint);
        const localStoragePlace = `localStorage['${this.debugKey}']`;
        await fse.writeFile(path.resolve(this.tempWidgetPath, 'script.js'), scriptFile.replace('@entrypoint@', `\${${localStoragePlace} || '${entrypoint}'}`));
        consola_1.default.success('Скрипт готов');
        consola_1.default.info(`Для дебага использовать ${localStoragePlace}`);
    }
    async prepareBundle() {
        if (this.entryPointIsURL) {
            return consola_1.default.info('Бандл не скопирован, так как входная точка - URL');
        }
        await fse.copy(this.bundleDir, path.resolve(this.tempWidgetPath, 'build'));
        consola_1.default.success('Бандл готов');
    }
    async createLocalesFolder() {
        return this.createFolder(this.localesPath);
    }
    async createImagesFolder() {
        return this.createFolder(this.imagesPath);
    }
    async createTempFolder() {
        return this.createFolder(this.tempWidgetPath);
    }
    async createFolder(path) {
        const exists = await fse.pathExists(path);
        if (!exists)
            await fse.mkdir(path);
    }
    get localesPath() {
        return path.resolve(this.tempWidgetPath, 'i18n');
    }
    get imagesPath() {
        return path.resolve(this.tempWidgetPath, 'images');
    }
    get tourImagesPath() {
        return path.resolve(this.imagesPath, 'tour');
    }
    get tempWidgetPath() {
        return path.resolve(__dirname, '../widget-temp');
    }
    get archivePath() {
        return path.resolve(this.config.outDir || path.resolve(this.tempWidgetPath, '..'), 'widget.zip');
    }
}
exports.WidgetBuilder = WidgetBuilder;
